data_type
===

- 数据类型
    - 基本数据类型
        - 数值型
            - 整数类型(int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, byte)
            - 浮点类型(float32, float64)
        - 字符型(没有专门的字符型, 使用byte保存单个字母字符)
        - 布尔型(bool)
        - 字符串(string)

## Why do we need data type?
- 从底层而言, 所有的数据都是由bit组成
- 数据类型是数据组织形式, 通过对数据的组织以表达更多的对象
- Golang数据类型分类
    - 基本类型
    - 复合类型
    - 引用类型
    - 接口类型

## 基本类型
### 整数类型
- 有符号整数类型, int8, int16, int32, in64
- 无符号整数类型, uint8, uint16, uint32, uint64
- int/uint OS相关, 编译器相关
- Unicode字符rune类型是和int32等价的类型, 通常用于表示一个Unicode码点
- byte类型适合uint8等价的类型, byte类型一般用于强调数值是一个原始的数据而不是一个小的整数
- uintptr机器相关, 足以容纳指针, 该类型只有在底层编程时才需要, 特别是Go语言和C语言函数库或操作系统接口相交互的地方
- 至于每个类型的表示范围, 与其他语言一样, 底层二进制补码表示, 老生常谈, 不再赘述
- Q: Golang有像Integer.MAX_VALUE这种东西么, A: 有, 在math包里, math.MaxInt64
int多大和系统有关,64位系统就默认8字节,uint也是,byte等价于uint8,
Golang的整形默认声明为int型,
如果查看变量的数据类型? fmt.Printf("n的类型为 %T", n), %T是类型的格式化
如何查看变量的字节大小? fmt.Printf("n的字节大小为 %d", n.sizeof())
Sizeof是unsafe包的函数,返回占用了几个字节
import (
    "fmt"
    "unsafe"
) 引用多个包这么写比较方便,当然一行一行写也没问题
如果没有使用一个包,但是又不想去掉,可以前面加一个下划线,表示暂时忽略
Golang整型变量的使用保小不保大,节省空间的原则,保存年龄用int64就不合理,byte其实就够了0-255

### 浮点类型
- 单精度float32,双精度float64,两者范围和精度不同
- Golang的浮点类型有固定的范围和字段长度,不受具体的OS影响
- Golang的浮点类型默认声明为float64
- 浮点型常量
- 十进制整数 5.12, .12,0可以省略
- 科学计数法, 3.14e2, 3.14e-2, 大写的E也可以
- float64的精度更高,推荐使用float64

### 字符类型
- Golang没有专门的字符类型,如果要存储单个字符,ASCII中的用byte
- Golang的字符串是由字节组成的? 这句话不太理解
- 直接输出byte变量的值,是在输出码值,如果想输出对应字符,用格式化%c
- 字符常量是由单引号括起来的单个字符
- Golang的字符编码是UTF-8编码的,UTF-8是Unicode的一种实现,UTF-8包含了ASCII
- 英文1字节,汉字3字节
- Go中字符的本质是一个整数,直接输出时,输出的是这个字符的UTF-8码值
- %c输出码值对应的字符,汉字也行
- 字符类型是可以进行运算的,因为本质都是整数嘛,比如 'a' + 2 就是'c'



### bool
- 用一个字节存储
- 只允许true/false, 不允许是数字, 不允许是空
- 和C语言不同, Golang的bool类型不能用0和非0来代替false和true

### string
- Golang的字符串是由单个字节拼接起来的
- Golang的字符串使用UTF-8编码标识Unicode文本
- Golang中字符串是不可变的, 也就是一旦赋值, 不能用过str[0] = 'a', 对其进行修改
- 双引号括起的字符串常量会识别转义字符, 反引号括起的字符串会以原生形式输出
- 字符串拼接用 +
- 当一个拼接操作很长时, 可以分行写, 但要记得把+留在上一行的结尾, 这里了解编译原理就了解为什么了, 当编译器识别到+结尾就不会给添加分号了

- 指针
基本数据类型,变量存的就是值,也叫值类型
&取地址和C一样,
指针类型,指针变量存的是一个地址,这个地址指向的空间存的才是值
var prt *int = &i
prt是指针变量,prt中存的是i的地址,指针变量本身这个空间肯定也有地址,不过我们不关心而已
*解引用,和C一样
值类型都有对应的指针类型,形式为 *数据类型, 比如int对应的指针类型是 *int
值类型包括基本数据类型int系列,float系列,bool,string,数组和结构体struct
- 值类型和引用类型
值类型包括基本数据类型int系列,float系列,bool,string,数组和结构体struct
引用类型: 指针,slice切片,map,管道channel,interface
值类型,变量直接存储值,内存通常在栈中分配
引用类型,变量存储的是一个地址,内存通常在堆上分配,当没有任何变量引用这个地址时,该地址对应的数据空间就成为一个垃圾,由GC来回收

## 基本数据类型间的转换
- Golang和Java, C/C++体系不同, 类型的概念特别强, 不同类型的变量之间赋值时需要显示转换, 也就是说Golang不存在类型提升之类的自动类型转换
- 无论是从小范围到大范围还是从大范围到小范围, 都需显示写明, 把大的给小的, 如果溢出不会报错, 只是按溢出处理
- 类型转换的语法
    - Golang的强制类型转换比较特别, 别记混了, type(变量名), Java的则是(type)变量名
    - i, ok := a.(int), 类型断言也能实现强制类型转换

### 基本数据类型和string的转换
- 基本数据类型转string
    - fmt.Sprintf("format", a), 返回转换后的string
    - 用strconv包中的函数
        - FormatInt/FormatFloat等函数将一个变量转换为int/float并返回字符串
    - itoa, 可以把int转为string
- string转基本数据类型
    - strconv中ParseInt, ParseFloat等返回的都是各个类型的64位, 注意, 不能用int去接, 要用int64接然后转成你需要的
    - 把不合法的转成基本数据类型, 比如把"hello"转成int, Go会转成这个类型的零值, 而不会报错